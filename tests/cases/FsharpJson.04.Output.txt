namespace Protokeep.FsharpJsonConverters
open System.Text.Json
open Protokeep.FsharpJsonConvertersHelpers
type ConvertDomain () =
    static member DefaultTrafficLight =
        lazy Domain.TrafficLight.Unknown
    static member TrafficLightFromString = function
        | "TrafficLightRed" -> Domain.TrafficLight.Red
        | "TrafficLightYellow" -> Domain.TrafficLight.Yellow
        | "TrafficLightGreen" -> Domain.TrafficLight.Green
        | _ -> Domain.TrafficLight.Unknown
    static member TrafficLightToString = function
        | Domain.TrafficLight.Red -> "TrafficLightRed"
        | Domain.TrafficLight.Yellow -> "TrafficLightYellow"
        | Domain.TrafficLight.Green -> "TrafficLightGreen"
        | _ -> "Unknown"
    static member LightStatusFromJson (reader: byref<Utf8JsonReader>): Domain.LightStatus =
        let mutable y = Domain.LightStatus.Unknown
        if reader.TokenType = JsonTokenType.StartObject || reader.Read() && reader.TokenType = JsonTokenType.StartObject then
            while reader.Read() && reader.TokenType <> JsonTokenType.EndObject do
                if reader.TokenType <> JsonTokenType.PropertyName then ()
                else if (reader.ValueTextEquals("Normal")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.True
                    then y <- Domain.LightStatus.Normal
                    else reader.Skip()
                else if (reader.ValueTextEquals("Warning")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.Number
                    then y <- reader.GetInt32() |> Domain.LightStatus.Warning
                    else reader.Skip()
                else if (reader.ValueTextEquals("OutOfOrder")) then
                    y <- ConvertDomain.LightStatusCaseOutOfOrderFromJson(&reader)
                else reader.Skip()
        y
    static member LightStatusToJson (writer:inref<Utf8JsonWriter>, x: Domain.LightStatus) =
        writer.WriteStartObject()
        match x with
        | Domain.LightStatus.Normal ->
            writer.WritePropertyName("Normal")
            writer.WriteBooleanValue(true)
        | Domain.LightStatus.Warning (errorsCount) ->
            writer.WritePropertyName("Warning")
            writer.WriteNumberValue(errorsCount)
        | Domain.LightStatus.OutOfOrder (since,period) ->
            writer.WritePropertyName("OutOfOrder")
            ConvertDomain.LightStatusCaseOutOfOrderToJson(&writer,since,period)
        | _ ->
            writer.WritePropertyName("Unknown")
            writer.WriteBooleanValue(true)
        writer.WriteEndObject()
    static member LightStatusCaseOutOfOrderFromJson (reader: byref<Utf8JsonReader>) =
        let mutable since = System.DateTime.MinValue
        let mutable period = System.TimeSpan.Zero
        if reader.TokenType = JsonTokenType.StartObject || reader.Read() && reader.TokenType = JsonTokenType.StartObject then
            while (reader.Read() && reader.TokenType <> JsonTokenType.EndObject) do
                if reader.TokenType <> JsonTokenType.PropertyName then ()
                else if (reader.ValueTextEquals("Since")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.String
                    then since <- reader.GetDateTime()
                    else reader.Skip()
                else if (reader.ValueTextEquals("Period")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.String
                    then period <- reader.GetString() |> toTimeSpan
                    else reader.Skip()
                else reader.Skip()
        Domain.LightStatus.OutOfOrder (since,period)
    static member LightStatusCaseOutOfOrderToJson (writer: inref<Utf8JsonWriter>,since,period) =
        writer.WriteStartObject()
        writer.WritePropertyName("Since")
        writer.WriteStringValue(since |> fromDateTime)
        writer.WritePropertyName("Period")
        writer.WriteStringValue(period |> fromTimeSpan)
        writer.WriteEndObject()
    static member DefaultCrossroad: Lazy<Domain.Crossroad> =
        lazy {
            Id = 0
            Street1 = ""
            Street2 = ""
            CurrentLight = ConvertDomain.DefaultTrafficLight.Value
            LightStatus = Domain.LightStatus.Unknown
        }
    static member CrossroadFromJson (reader: byref<Utf8JsonReader>): Domain.Crossroad =
        let mutable vId = 0
        let mutable vStreet1 = ""
        let mutable vStreet2 = ""
        let mutable vCurrentLight = ConvertDomain.DefaultTrafficLight.Value
        let mutable vLightStatus = Domain.LightStatus.Unknown
        if reader.TokenType = JsonTokenType.StartObject || reader.Read() && reader.TokenType = JsonTokenType.StartObject then
            while (reader.Read() && reader.TokenType <> JsonTokenType.EndObject) do
                if reader.TokenType <> JsonTokenType.PropertyName then ()
                else if (reader.ValueTextEquals("Id")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.Number
                    then vId <- reader.GetInt32()
                    else reader.Skip()
                else if (reader.ValueTextEquals("Street1")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.String
                    then vStreet1 <- reader.GetString()
                    else reader.Skip()
                else if (reader.ValueTextEquals("Street2")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.String
                    then vStreet2 <- reader.GetString()
                    else reader.Skip()
                else if (reader.ValueTextEquals("CurrentLight")) then
                    if reader.Read() && reader.TokenType = JsonTokenType.String
                    then vCurrentLight <- reader.GetString() |> ConvertDomain.TrafficLightFromString
                    else reader.Skip()
                else if (reader.ValueTextEquals("LightStatus")) then
                    vLightStatus <- ConvertDomain.LightStatusFromJson(&reader)
                else reader.Skip()
        {
            Id = vId
            Street1 = vStreet1
            Street2 = vStreet2
            CurrentLight = vCurrentLight
            LightStatus = vLightStatus
        }
    static member CrossroadToJson (writer: inref<Utf8JsonWriter>, x: Domain.Crossroad) =
        writer.WriteStartObject()
        writer.WritePropertyName("Id")
        writer.WriteNumberValue(x.Id)
        writer.WritePropertyName("Street1")
        writer.WriteStringValue(x.Street1)
        writer.WritePropertyName("Street2")
        writer.WriteStringValue(x.Street2)
        writer.WritePropertyName("CurrentLight")
        writer.WriteStringValue(x.CurrentLight |> ConvertDomain.TrafficLightToString)
        writer.WritePropertyName("LightStatus")
        ConvertDomain.LightStatusToJson(&writer, x.LightStatus)
        writer.WriteEndObject()
